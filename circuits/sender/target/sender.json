{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"14991209215158745165","abi":{"parameters":[{"name":"sig","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"address","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"proof_p_siblings","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof_p_depth_eff","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"proof_c_siblings","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof_c_depth_eff","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"r","type":{"kind":"field"},"visibility":"public"},{"name":"event_hi","type":{"kind":"field"},"visibility":"public"},{"name":"event_lo","type":{"kind":"field"},"visibility":"public"},{"name":"root_p","type":{"kind":"field"},"visibility":"public"},{"name":"root_c","type":{"kind":"field"},"visibility":"public"},{"name":"null_s","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"285656119219400463":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"5795655218219125583":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"},"12161378539035059347":{"error_kind":"string","string":"Field failed to decompose into specified 254 limbs"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use dep::ecrecover;\nuse poseidon::poseidon2::Poseidon2;\nmod sparse_merkle_tree;\nmod u128BE;\n\nglobal DEPTH: u32 = 20;\n\nfn main(\n    // PRIVATE INPUTS\n    sig: [u8; 64], // r||s ECDSA signature\n    pub_key_x: [u8; 32], // x coordinate of public key\n    pub_key_y: [u8; 32], // y coordinate of public key\n    address: [u8; 20], // address of the sender\n    proof_p_siblings: [Field; DEPTH], // siblings of the proof for participants\n    proof_p_depth_eff: u32, // depth of the proof for participants\n    proof_c_siblings: [Field; DEPTH], // siblings of the proof for commitments\n    proof_c_depth_eff: u32, // depth of the proof for commitments\n\n    // PUBLIC INPUTS\n    r: pub Field, // randomness\n    event_hi: pub Field, // top 128 bits of eventId\n    event_lo: pub Field, // bottom 128 bits of eventId\n    root_p: pub Field, // root of the participants SMT\n    root_c: pub Field, // root of the commitments SMT\n    null_s: pub Field, // nullifier sender\n\n) {\n    // 1. Convert the event id to bytes\n    let hi16 = u128BE::field_to_u128_bytes16_be(event_hi);\n    let lo16 = u128BE::field_to_u128_bytes16_be(event_lo);\n\n    let mut event_id_bytes: [u8; 32] = [0; 32];\n    for i in 0..16 { event_id_bytes[i] = hi16[i]; }\n    for i in 0..16 { event_id_bytes[16 + i] = lo16[i]; }\n\n    // 2. Compute the message\n    let mut msg: [u8; 52] = [0; 52]; // 20 bytes for address + 32 bytes for event id\n    for i in 0..20 { // copy address to msg\n        msg[i] = address[i];\n    }\n    for i in 0..32 { // copy event id to msg\n        msg[i + 20] = event_id_bytes[i];\n    }\n    let hashed_msg: [u8; 32] = keccak256::keccak256(msg, 52); // hash the message\n    \n    // 3. Recover the address\n    let recovered: Field = ecrecover::ecrecover(pub_key_x, pub_key_y, sig, hashed_msg);  // recover the address\n    assert(recovered != Field::from(0)); // check that the address is not the zero address\n\n    // 4. Convert the address to Field\n    let mut padded: [u8; 32] = [0; 32]; // pad the address with 12 bytes of zeros\n    for i in 0..20 {\n        padded[12 + i] = address[i];\n    }\n    let address_field = Field::from_be_bytes(padded); // convert the address to Field\n    assert(recovered == address_field); // check that the recovered address matches the input address\n    \n    // 5. Compute the nullifier\n    let mut s_bytes: [u8; 32] = [0; 32]; // extract s from the signature\n    for i in 0..32 {\n        s_bytes[i] = sig[i + 32]; // copy s to s_bytes\n    }\n    let s_field = Field::from_be_bytes(s_bytes); // convert s_bytes to Field\n    let computed_nulls = Poseidon2::hash([s_field], 1); // compute the nullifier\n    assert(computed_nulls == null_s); // check that the computed nullifier matches the input nullifier\n\n    // 6. H = hash(sig)\n    let mut r_bytes: [u8; 32] = [0; 32]; // extract r from the signature\n    for i in 0..32 {\n        r_bytes[i] = sig[i]; // copy r to r_bytes\n    }\n    let r_field = Field::from_be_bytes(r_bytes); // convert r_bytes to Field\n    let H = Poseidon2::hash([r_field, s_field], 2); // compute H\n\n    // 7. Merkle verify participants\n    let root_p_calc = sparse_merkle_tree::smt_process_proof(\n        Poseidon2::hash([address_field], 1),\n        address_field,\n        proof_p_siblings,\n        proof_p_depth_eff,\n    ); // compute the root of the participants SMT\n    assert(root_p_calc == root_p); // check that the computed root matches the input root\n    \n    // 8. Merkle verify commitments\n    let root_c_calc = sparse_merkle_tree::smt_process_proof(\n        H,\n        H,\n        proof_c_siblings,\n        proof_c_depth_eff,\n    ); // compute the root of the commitments SMT\n    assert(root_c_calc == root_c); // check that the computed root matches the input root\n\n    // 9. Anchor\n    let r_sq = r * r;\n    assert(r_sq == r_sq);\n}\n\n","path":"/home/david/zk-cyfrin/santa-secret/circuits/sender/src/main.nr"},"51":{"source":"use poseidon::poseidon2::Poseidon2;\r\n\r\nglobal DEPTH: u32 = 20;\r\n\r\npub fn smt_process_proof(\r\n    key: Field,\r\n    value: Field,\r\n    siblings: [Field; DEPTH],\r\n    depth_eff: u32\r\n) -> Field {\r\n    let mut h = Poseidon2::hash([key, value, Field::from(1)], 3);\r\n    let bits: [u1; 254] = key.to_le_bits();\r\n\r\n    for j in 0..DEPTH { // for each level of the SMT\r\n        let i = (DEPTH - 1 - j) as u32; // i = DEPTH - 1 - j\r\n\r\n        if i < depth_eff { // if the current level is within the depth of the proof\r\n            let sib = siblings[i]; // sib = siblings[i]\r\n            let bit = bits[i]; // bit = bits[i]\r\n\r\n            if bit == 1 {\r\n                h = Poseidon2::hash([sib, h], 2); // h = hash(sibling, h)\r\n            } else {\r\n                h = Poseidon2::hash([h, sib], 2); // h = hash(h, sibling)\r\n            }\r\n        }\r\n    }\r\n\r\n    h // return the root of the SMT\r\n}","path":"/home/david/zk-cyfrin/santa-secret/circuits/sender/src/sparse_merkle_tree.nr"},"52":{"source":"pub fn field_to_u128_bytes16_be(x: Field) -> [u8; 16] {\r\n    let b: [u8; 32] = x.to_be_bytes();\r\n    // x must fit in 128 bits => top 16 bytes are 0\r\n    for i in 0..16 {\r\n        assert(b[i] == 0);\r\n    }\r\n    let mut out: [u8; 16] = [0; 16];\r\n    for i in 0..16 {\r\n        out[i] = b[16 + i];\r\n    }\r\n    out\r\n}\r\n","path":"/home/david/zk-cyfrin/santa-secret/circuits/sender/src/u128BE.nr"},"53":{"source":"mod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/david/nargo/github.com/colinnielsen/ecrecover-noir/v1.0.0/src/lib.nr"},"54":{"source":"use dep::keccak256;\nuse dep::array_helpers;\n\npub struct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    pub fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    pub fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    pub fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64(self.pub_x, self.pub_y);\n        let hashed_pub_key = keccak256::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/home/david/nargo/github.com/colinnielsen/ecrecover-noir/v1.0.0/src/secp256k1.nr"},"57":{"source":"mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n","path":"/home/david/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"},"65":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/david/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"}},"names":["main"],"brillig_names":["directive_to_radix","directive_invert","directive_integer_quotient"]}